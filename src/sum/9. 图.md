#### 1. 基本概念

> 图：由顶点的集合和边的集合组成G = (V, E)
>
> 边：一幅点对 $(v,w)v,w \in V$
>
> - 权(weight)：边附带的信息
> - 值(cost)：也是边附带的信息
> - 邻接顶点：若两个顶点在同一条边上，则这两个顶点互为顶点
> - 顶点的度：该顶点有多少条边关联
> - 路径：从某点到某点的经过的边和顶点组成路径
> - 路径长度：一条路径上的边的条数
>
> 有向图：点对是有序的图
>
> 无向图：每一条边存在(v, w)，也存在边(w, v)的图
>
> 完全图：每一对顶点间都存在一条边的图(n为顶点数)
>
> - 无向图边数：n(n - 1)/2
> - 有向图变数：n(n - 1)
>
> 强连通图：所有顶点都是连通的

#### 2. 图的存储结构

> 1. 邻接矩阵：效率空间较大，n个顶点需要n*n大小的矩阵
>
>    > 无权图：每个坐标下的值为1代表相连，0(无穷大)不相连
>    >
>    > 有权图：每个坐标下的值为权值代表相连，0(无穷大)不相连
>
> 2. 邻接链表：在查找上耗时比较大
>
>    > 对于每个点，存储一个链表，用来指向所有与该点直接相连的点

#### 3. 最小生成树

> 定义：一个有n个顶点的连通图的生成树是原图的极小连通子图，它包含原图中的所有n个顶点并且具有保持图连通的最少的边；无论添加或删除一条边都会影响定义。
>
> **普利姆算法Prim**：
>
> > 1. 对于一个加权连通图，其顶点集合为V，边集合为E。从集合V中人选一个顶点作为初始顶点，将该顶点标记为处理
> > 2. 已处理的所有顶点可以看成一个集合U，计算所有于集合U相邻顶点的距离，选择距离最短的顶点，将其标记为已处理，并记录最短距离的边
> > 3. 不断计算已处理的顶点集合U和未处理的顶点的距离，每次选出距离最短的顶点标为已处理，同时记录最短距离的边，直至所有顶点都处理完。
> > 4. 最终，所有记录的最短距离的边构成的树：就是生成树

#### 4. 最短路径

> 定义：路径最短的路径作为最短路径
>
> 狄克斯特拉算法Dijkstra：
>
> > 设置两个顶点的集合S和T，集合S中存放已找到最短路径的顶点，集合T中存放当前还没找到最短路径的顶点。初始状态时，集合S中只包含源点，设为$V_o$，然后从集合T中选择到源点$V_o$路径长度最短的顶点u加入到集合S中，集合S中每加入一个新的顶点u，都需要修改源点$V_o$到集合T中剩余顶点的当前最短路径长度值，集合T中各顶点的新的当前最短路径长度值为原来的当前最短路径长度值与从源点过顶点u到达该顶点的路径长度中的较小者。此过程不断重复，直到集合T中的顶点全部加入到集合S中为止

实际编码，以后再回来补充吧