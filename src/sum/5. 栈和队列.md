### 1. 栈

#### 1. 基本概念

> 栈：只允许固定一段进行插入和删除数据元素操作：(LIFO：后进后出的表)
>
> ![](https://pic.downk.cc/item/5ff6cc373ffa7d37b3389c21.png)
>
> 栈顶(top)：运行插入push和删除pop元素的一端，另一端为栈底

#### 2. 实现方式

> 1. 单链表：插入和删除操作都在链表的表头进行。
> 2. 数组：模仿ArrayList的add操作，用个类变量记录top位置(添加就+1，删除就减少1)

#### 3. 递归的方式

> - 调用函数：每次调用一个函数的时候，系统都会重新开辟一个与这个函数相对应的栈帧
>
> - 普通递归：需要上一个函数的环境
>
>   内存占用：创建stack累积而后计算收缩
>
> - 尾递归：不需要上一个函数的环境，直接return值的
>
>   内存占用：只会占用恒量的内存(和迭代一样)(JVM好像没有优化)

### 2. 队列

#### 1. 基本概念

> 队列：插入在一端进行而删除则在另一端进行
>
> ![](https://img.imgdb.cn/item/5ffd1adf3ffa7d37b3b3b3d1.png)
>
> 入队(enqueue): 在队尾(rear)插入一个元素
> 出队(dequeue): 在队头(front)删除一个元素，并返回这个元素 

#### 2. 实现方式

> 顺序数组：用两个指针front和back分别代表队头和队尾；back到达尾部就停止入队，front到达back就停止出队。**会造成假溢出，造成内存的浪费**。
>
> ![](https://img.imgdb.cn/item/5ffd332f3ffa7d37b3c51a00.png)
>
> **循环数组**：用两个指针front和back分别代表队头和队尾，只要front或back到达数组的尾端，就绕回到开头。
>
> - 采用留空一个空间的方式来实现循环数组：
>
>   ```java
>   /** 
>    * 借助空一个长度的数组，来达成区分空和满
>    * 空: rear == front
>    * 满: (rear + 1) % MAX_QUEUE_SIZE == front
>    *
>    * 不足，少了一个空间，并且索引和判断满都需要%操作，需要时间多
>    */
>   ```
>
> - 设置一个标志位来实现循环数组：初始为0，添加置为1，删除置为0
>
>   ```java
>   /**
>   * tag == 0 && rear == front 为空
>   * tag == 1 && rear == front 为满
>   *
>   * 优点: 可以满空间使用了，但是借助了额外的标志位
>   * 缺点: 求余操作还是没有处理掉
>   */
>   ```
>
> - 通过count统计使用个数，初始为0，添加+ 1，删除减1
>
>   ```java
>   /**
>    * 空: count == 0
>    * 满: count == MAX_QUERY_SIZE
>    *
>    * 优点: 额外知道具体使用了多少个空间
>    * 缺点: %还是在
>    */
>   ```
>
> 使用动态扩容数组进行实现队列：**借助List，解决空间不够的情况**
>
> 链表实现：在头删除，在尾巴插入。**双向链表**
>
> ```java
> Queue<Integer> queue = new LinkedList<>();
> ```

