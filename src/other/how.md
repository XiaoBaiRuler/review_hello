#### [191. 位1的个数](https://leetcode-cn.com/problems/number-of-1-bits/)

> 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为[汉明重量](https://baike.baidu.com/item/汉明重量)）。
>
> 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
> 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。
>
> 解题思路1：整数转为二进制字符串，再逐个判断是不是1，是1：计数器加1
>
> [代码](Other_01.java)

#### [461. 汉明距离](https://leetcode-cn.com/problems/hamming-distance/)

> 两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。
>
> 给出两个整数 x 和 y，计算它们之间的汉明距离。
>
> 注意：
> 0 ≤ x, y < 231.
>
> 解题思路1：先异或，再统计1的数量
>
> [代码](Other_02.java)

#### [190. 颠倒二进制位](https://leetcode-cn.com/problems/reverse-bits/)

> 颠倒给定的 32 位无符号整数的二进制位。
>
> 解题思路1：本来使用转为二进制字符串，再反转之后再在前补0，可以上传leetcode会报奇怪的错误，看了一下答案：感觉用位运算的做法不错
>
> > 1. 将给定的二进制数，由低到高逐个取出(右移i位，并&1取出有效位)
> > 2. 通过位运算将其放置到反转后的位置(tmp<<31 - i)
> > 3. 将反转后的结果和result结合(result是1且tmp的有效位是1，就是1；result是0且tmp的有效位是0，也是0；其他位都以result的编码)
> > 4. 重复以上步骤，直到i == 32位
>
> [代码](Other_03.java)

#### [118. 杨辉三角](https://leetcode-cn.com/problems/pascals-triangle/)

> 给定一个非负整数 *numRows，*生成杨辉三角的前 *numRows* 行。
>
> 解题思路1：照着规则运算一遍就行了
>
> [代码](Other_04.java)

#### [268. 丢失的数字](https://leetcode-cn.com/problems/missing-number/)

> 给定一个包含 `[0, n]` 中 `n` 个数的数组 `nums` ，找出 `[0, n]` 这个范围内没有出现在数组中的那个数。
>
> 解题思路1:
>
> > $1 + 2 + 3 + ... + N = \frac {n (n + 1)}{2}$
> >
> > 少一个数字，遍历：逐个数字减少，最后剩余的就是缺少的那个
>
> [代码](Other_05.java)